// Code generated by truss.
// Rerunning truss will overwrite this file.
// DO NOT EDIT!
// Version: a41ee29fb6
// Version Date: Fri May 26 18:19:22 UTC 2017

package svc

// This file provides server-side bindings for the HTTP transport.
// It utilizes the transport/http.Server.

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"

	"golang.org/x/net/context"

	"github.com/go-kit/kit/log"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/pkg/errors"

	// This service
	pb "github.com/zaquestion/current/current-service"
)

var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = pb.RegisterCurrentServer
	_ = io.Copy
	_ = errors.Wrap
)

// MakeHTTPHandler returns a handler that makes a set of endpoints available
// on predefined paths.
func MakeHTTPHandler(ctx context.Context, endpoints Endpoints, logger log.Logger) http.Handler {
	serverOptions := []httptransport.ServerOption{
		httptransport.ServerBefore(headersToContext),
		httptransport.ServerErrorEncoder(errorEncoder),
	}
	m := http.NewServeMux()

	m.Handle("/location/bigbrother", httptransport.NewServer(
		ctx,
		endpoints.PostLocationBigBrotherEndpoint,
		DecodeHTTPPostLocationBigBrotherZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Handle("/location/tasker", httptransport.NewServer(
		ctx,
		endpoints.PostLocationTaskerEndpoint,
		DecodeHTTPPostLocationTaskerZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))

	m.Handle("/location", httptransport.NewServer(
		ctx,
		endpoints.GetLocationEndpoint,
		DecodeHTTPGetLocationZeroRequest,
		EncodeHTTPGenericResponse,
		serverOptions...,
	))
	return m
}

func errorEncoder(_ context.Context, err error, w http.ResponseWriter) {
	code := http.StatusInternalServerError
	msg := err.Error()

	w.WriteHeader(code)
	json.NewEncoder(w).Encode(errorWrapper{Error: msg})
}

type errorWrapper struct {
	Error string `json:"error"`
}

// Server Decode

// DecodeHTTPPostLocationBigBrotherZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded postlocationbigbrother request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPostLocationBigBrotherZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.PostLocationBigBrotherRequest
	err := json.NewDecoder(r.Body).Decode(&req)
	// err = io.EOF if r.Body was empty
	if err != nil && err != io.EOF {
		return nil, errors.Wrap(err, "decoding body of http request")
	}

	pathParams, err := PathParams(r.URL.Path, "/location/bigbrother")
	_ = pathParams
	if err != nil {
		return nil, errors.Wrap(err, "couldn't unmarshal path parameters")
	}

	queryParams := r.URL.Query()
	_ = queryParams

	if LatitudePostLocationBigBrotherStrArr, ok := queryParams["latitude"]; ok {
		LatitudePostLocationBigBrotherStr := LatitudePostLocationBigBrotherStrArr[0]
		LatitudePostLocationBigBrother, err := strconv.ParseFloat(LatitudePostLocationBigBrotherStr, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LatitudePostLocationBigBrother from query, queryParams: %v", queryParams))
		}
		req.Latitude = LatitudePostLocationBigBrother
	}

	if LongitudePostLocationBigBrotherStrArr, ok := queryParams["longitude"]; ok {
		LongitudePostLocationBigBrotherStr := LongitudePostLocationBigBrotherStrArr[0]
		LongitudePostLocationBigBrother, err := strconv.ParseFloat(LongitudePostLocationBigBrotherStr, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting LongitudePostLocationBigBrother from query, queryParams: %v", queryParams))
		}
		req.Longitude = LongitudePostLocationBigBrother
	}

	if AccuracyPostLocationBigBrotherStrArr, ok := queryParams["accuracy"]; ok {
		AccuracyPostLocationBigBrotherStr := AccuracyPostLocationBigBrotherStrArr[0]
		AccuracyPostLocationBigBrother, err := strconv.ParseFloat(AccuracyPostLocationBigBrotherStr, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting AccuracyPostLocationBigBrother from query, queryParams: %v", queryParams))
		}
		req.Accuracy = AccuracyPostLocationBigBrother
	}

	if AltitudePostLocationBigBrotherStrArr, ok := queryParams["altitude"]; ok {
		AltitudePostLocationBigBrotherStr := AltitudePostLocationBigBrotherStrArr[0]
		AltitudePostLocationBigBrother, err := strconv.ParseFloat(AltitudePostLocationBigBrotherStr, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting AltitudePostLocationBigBrother from query, queryParams: %v", queryParams))
		}
		req.Altitude = AltitudePostLocationBigBrother
	}

	if BearingPostLocationBigBrotherStrArr, ok := queryParams["bearing"]; ok {
		BearingPostLocationBigBrotherStr := BearingPostLocationBigBrotherStrArr[0]
		BearingPostLocationBigBrother, err := strconv.ParseFloat(BearingPostLocationBigBrotherStr, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting BearingPostLocationBigBrother from query, queryParams: %v", queryParams))
		}
		req.Bearing = BearingPostLocationBigBrother
	}

	if SpeedPostLocationBigBrotherStrArr, ok := queryParams["speed"]; ok {
		SpeedPostLocationBigBrotherStr := SpeedPostLocationBigBrotherStrArr[0]
		SpeedPostLocationBigBrother, err := strconv.ParseFloat(SpeedPostLocationBigBrotherStr, 64)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting SpeedPostLocationBigBrother from query, queryParams: %v", queryParams))
		}
		req.Speed = SpeedPostLocationBigBrother
	}

	if BattlevelPostLocationBigBrotherStrArr, ok := queryParams["battlevel"]; ok {
		BattlevelPostLocationBigBrotherStr := BattlevelPostLocationBigBrotherStrArr[0]
		BattlevelPostLocationBigBrother, err := strconv.ParseInt(BattlevelPostLocationBigBrotherStr, 10, 32)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("Error while extracting BattlevelPostLocationBigBrother from query, queryParams: %v", queryParams))
		}
		req.Battlevel = int32(BattlevelPostLocationBigBrother)
	}

	if TimePostLocationBigBrotherStrArr, ok := queryParams["time"]; ok {
		TimePostLocationBigBrotherStr := TimePostLocationBigBrotherStrArr[0]
		TimePostLocationBigBrother := TimePostLocationBigBrotherStr
		req.Time = TimePostLocationBigBrother
	}

	return &req, err
}

// DecodeHTTPPostLocationTaskerZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded postlocationtasker request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPPostLocationTaskerZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.PostLocationTaskerRequest
	err := json.NewDecoder(r.Body).Decode(&req)
	// err = io.EOF if r.Body was empty
	if err != nil && err != io.EOF {
		return nil, errors.Wrap(err, "decoding body of http request")
	}

	pathParams, err := PathParams(r.URL.Path, "/location/tasker")
	_ = pathParams
	if err != nil {
		return nil, errors.Wrap(err, "couldn't unmarshal path parameters")
	}

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// DecodeHTTPGetLocationZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded getlocation request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetLocationZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.GetLocationRequest
	err := json.NewDecoder(r.Body).Decode(&req)
	// err = io.EOF if r.Body was empty
	if err != nil && err != io.EOF {
		return nil, errors.Wrap(err, "decoding body of http request")
	}

	pathParams, err := PathParams(r.URL.Path, "/location")
	_ = pathParams
	if err != nil {
		return nil, errors.Wrap(err, "couldn't unmarshal path parameters")
	}

	queryParams := r.URL.Query()
	_ = queryParams

	return &req, err
}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(_ context.Context, w http.ResponseWriter, response interface{}) error {
	return json.NewEncoder(w).Encode(response)
}

// Helper functions

// PathParams takes a url and a gRPC-annotation style url template, and
// returns a map of the named parameters in the template and their values in
// the given url.
//
// PathParams does not support the entirety of the URL template syntax defined
// in third_party/googleapis/google/api/httprule.proto. Only a small subset of
// the functionality defined there is implemented here.
func PathParams(url string, urlTmpl string) (map[string]string, error) {
	rv := map[string]string{}
	pmp := BuildParamMap(urlTmpl)

	expectedLen := len(strings.Split(strings.TrimRight(urlTmpl, "/"), "/"))
	recievedLen := len(strings.Split(strings.TrimRight(url, "/"), "/"))
	if expectedLen != recievedLen {
		return nil, fmt.Errorf("Expected a path containing %d parts, provided path contains %d parts", expectedLen, recievedLen)
	}

	parts := strings.Split(url, "/")
	for k, v := range pmp {
		rv[k] = parts[v]
	}

	return rv, nil
}

// BuildParamMap takes a string representing a url template and returns a map
// indicating the location of each parameter within that url, where the
// location is the index as if in a slash-separated sequence of path
// components. For example, given the url template:
//
//     "/v1/{a}/{b}"
//
// The returned param map would look like:
//
//     map[string]int {
//         "a": 2,
//         "b": 3,
//     }
func BuildParamMap(urlTmpl string) map[string]int {
	rv := map[string]int{}

	parts := strings.Split(urlTmpl, "/")
	for idx, part := range parts {
		if strings.ContainsAny(part, "{}") {
			param := RemoveBraces(part)
			rv[param] = idx
		}
	}
	return rv
}

// RemoveBraces replace all curly braces in the provided string, opening and
// closing, with empty strings.
func RemoveBraces(val string) string {
	val = strings.Replace(val, "{", "", -1)
	val = strings.Replace(val, "}", "", -1)
	return val
}

func headersToContext(ctx context.Context, r *http.Request) context.Context {
	for k, _ := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	return ctx
}

func HTTPDecodeLogger(next httptransport.DecodeRequestFunc, logger log.Logger) httptransport.DecodeRequestFunc {
	return func(ctx context.Context, r *http.Request) (interface{}, error) {
		logger.Log("method", r.Method, "url", r.URL.String())
		rv, err := next(ctx, r)
		if err != nil {
			logger.Log("method", r.Method, "url", r.URL.String(), "Error", err)
		}
		return rv, err
	}
}
